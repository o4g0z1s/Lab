<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32'><text x='16' y='24' font-size='24' text-anchor='middle' fill='orange'>🌌</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Emoji:wght@300..700&display=swap" rel="stylesheet">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-E675FYQ3DK"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-E675FYQ3DK');
    </script>
    <title>𝚂𝚞𝚙𝚎𝚛𝚗𝚘𝚟𝚊</title>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
        }
        body {
            font-family: "Noto Emoji", Helvetica;
            background-color: #000;
            filter: hue-rotate(30deg);
        }

        #kaleidoscope-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .text {
            position: absolute;
            white-space: nowrap;
            transform-origin: center center;
        }
    </style>
</head>
<body>

<div id="kaleidoscope-container"></div>

<script>
    // --- 設定値 ---
    const KALEIDOSCOPE_SEGMENTS = 8; 

    const isSmallScreen = window.innerWidth < 768;

    let maxFontSize;
    let numberOfBasePatterns;

    if (isSmallScreen) {
        maxFontSize = 60; 
        numberOfBasePatterns = 25; 
    } else {
        maxFontSize = 150;
        numberOfBasePatterns = 40; 
    }
    
    // --- コンテナのセットアップ ---
    const container = document.getElementById('kaleidoscope-container');
    const artboardSize = Math.min(window.innerWidth, window.innerHeight);
    container.style.width = `${artboardSize}px`;
    container.style.height = `${artboardSize}px`;

    const centerX = artboardSize / 2;
    const centerY = artboardSize / 2;

    // --- ユーティリティ関数 ---
function getRandomColor() {
    const hue = Math.floor(Math.random() * 360);
    const saturation = Math.floor(30 + Math.random() * 60);
    const lightness = Math.floor(50 + Math.random() * 20);
    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}
    function getRandomUnicodeChar() {
        const unicodeRange = [ [0x2500, 0x2775], [0x0531, 0x2E42], [0x0531, 0x2E42], [0xA000, 0xABF9] ];
        let codePoint;
        const range = unicodeRange[Math.floor(Math.random() * unicodeRange.length)];
        codePoint = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
        return String.fromCharCode(codePoint);
    }

    // --- 万華鏡アート生成関数 ---
    function createTextElement(x, y, char, color, fontSize, rotation, isMirrored) {
        const textElement = document.createElement('div');
        textElement.className = 'text';
        textElement.textContent = char;
        textElement.style.fontSize = `${fontSize}px`;
        textElement.style.color = color;
        textElement.style.left = `${x}px`;
        textElement.style.top = `${y}px`;
        
        let transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
        if (isMirrored) {
            transform += ' scaleY(-1)';
        }
        textElement.style.transform = transform;
        
        container.appendChild(textElement);
    }

    function createSymmetricalGroup() {
        const char = getRandomUnicodeChar();
        const color = getRandomColor();
        const initialRotation = Math.random() * 360;
        
        const safeMargin = maxFontSize / 2;
        const maxRadius = (artboardSize / 2) - safeMargin;
        if (maxRadius <= 0) return;

        const radius = Math.sqrt(Math.random()) * maxRadius;

        const minFontSize = 50;
        
        const fontSizeFactor = radius / maxRadius; // 0.0 (中心) ~ 1.0 (外縁) の値
        const dynamicMaxFontSize = (maxFontSize - minFontSize) * fontSizeFactor;
        const fontSize = Math.random() * dynamicMaxFontSize + minFontSize;

        const segmentAngleRad = 2 * Math.PI / KALEIDOSCOPE_SEGMENTS;
        const angleRad = Math.random() * segmentAngleRad;

        for (let i = 0; i < KALEIDOSCOPE_SEGMENTS; i++) {
            const currentSegmentAngleRad = i * segmentAngleRad;

            const currentAngleRad = angleRad + currentSegmentAngleRad;
            const x = centerX + radius * Math.cos(currentAngleRad);
            const y = centerY + radius * Math.sin(currentAngleRad);
            const rotationDeg = initialRotation + (currentSegmentAngleRad * 180 / Math.PI);
            createTextElement(x, y, char, color, fontSize, rotationDeg, false);

            const mirroredAngleRad = -angleRad + currentSegmentAngleRad;
            const mirroredX = centerX + radius * Math.cos(mirroredAngleRad);
            const mirroredY = centerY + radius * Math.sin(mirroredAngleRad);
            const mirroredRotationDeg = -initialRotation + (currentSegmentAngleRad * 180 / Math.PI);
            createTextElement(mirroredX, mirroredY, char, color, fontSize, mirroredRotationDeg, true);
        }
    }

    function generateKaleidoscopeArt() {
        for (let i = 0; i < numberOfBasePatterns; i++) {
            createSymmetricalGroup();
        }
    }

    // --- 初期化処理 ---
    generateKaleidoscopeArt();

    (function() {
      const target = document.body;
    
      const filterConfigs = {
        blur: { min: 0, max: 3, unit: 'px' },
        contrast: { min: 80, max: 200, unit: '%' },
        brightness: { min: 80, max: 180, unit: '%' },
        saturate: { min: 80, max: 200, unit: '%' },
        invert: { min: 0, max: 10, unit: '%' },
        'hue-rotate': { min: 0, max: 360, unit: 'deg' }
      };
    
      function randRange(min, max) {
        return Math.random() * (max - min) + min;
      }
    
      class SparkField {
        constructor(name, cfg) {
          this.name = name;
          this.min = cfg.min; this.max = cfg.max;
          this.unit = cfg.unit || '';
          this.current = randRange(this.min, this.max);
          this.target = randRange(this.min, this.max);
          this.prev = this.current;
          this.period = randRange(0.2, 0.5);
          this.elapsed = 0;
        }
    
        setNewTarget() {
          this.prev = this.current;
          this.target = randRange(this.min, this.max);
          this.period = randRange(0.2, 0.5);
          this.elapsed = 0;
        }
    
        update(dt) {
          this.elapsed += dt;
          let t = Math.min(1, this.elapsed / this.period);
          const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          this.current = this.prev + (this.target - this.prev) * eased;
          if (t >= 1) {
            this.prev = this.current;
            this.setNewTarget();
          }
        }
    
        getValueWithUnit() {
          return this.current.toFixed(2).replace(/\.00$/, '') + this.unit;
        }
      }
    
      const fields = {};
      Object.keys(filterConfigs).forEach(key => {
        fields[key] = new SparkField(key, filterConfigs[key]);
      });
    
      function composeFilterString() {
        const parts = [];
        Object.keys(fields).forEach(key => {
          parts.push(`${key}(${fields[key].getValueWithUnit()})`);
        });
        return parts.join(' ');
      }
    
      let lastTime = performance.now();
      let rAF = null;
      let running = true;
    
      function loop(now) {
        if (!running) return;
        const dt = Math.min(0.033, (now - lastTime) / 1000);
        lastTime = now;
    
        Object.values(fields).forEach(f => f.update(dt));
        target.style.filter = composeFilterString();
    
        rAF = requestAnimationFrame(loop);
      }
    
      function start() {
        if (rAF) cancelAnimationFrame(rAF);
        lastTime = performance.now();
        running = true;
        rAF = requestAnimationFrame(loop);
      }
    
      function stop() {
        running = false;
        if (rAF) cancelAnimationFrame(rAF);
      }
    
      window.addEventListener('beforeunload', stop);
      start();
    
      window.startRandomFilter = start;
      window.stopRandomFilter = stop;
    })();
</script>
</body>
</html>