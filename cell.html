<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <link rel="icon" href="https://s.yimg.com/ny/api/res/1.2/dOVWY5V2rBuRG4oojoCuxg--/YXBwaWQ9aGlnaGxhbmRlcjt3PTY0MA--/https://media.zenfs.com/en/the_conversation_464/e85d3807a7702782af88875abfcf8369">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300&family=Noto+Sans+Math&family=Roboto:wght@300&display=swap" rel="stylesheet">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-E675FYQ3DK"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-E675FYQ3DK');
    </script>
    <title>Concellt - MIDI Sequencer</title>
    <style>
        :root {
            --cell-width: 35px; --cell-height: 25px; --grid-gap: 2px;
            --main-accent-color: #a5d6a7; --note-color: #66bb6a; --note-hover-color: #81c784;
            --text-color: #e0e0e0; --bg-color: #1c1c1c; --bg-secondary-color: #272727;
            --bg-tertiary-color: #333333; --border-color: #404040; --cell-bg-color: #383838;
            --cell-bg-c-octave-color: #424242; --playing-head-highlight-bg: #535353;
            
            --drum-cell-bg-color: var(--cell-bg-color); 
            --drum-cell-active-color: var(--note-color); 
            --drum-cell-hover-color: #4a4a4a; 
            --drum-cell-active-hover-color: var(--note-hover-color); 
        }
        body, html {
            font-family: "Roboto", sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            height: 100dvh; margin: 0; overflow: hidden; font-size: 14px;
        }
        .container { 
            display: flex; flex-direction: column; 
            /* height: 100vh; MODIFIED: Removed, will be set by JS */
            background-color: var(--bg-secondary-color); 
        }
        h1 { text-align: center; color: var(--main-accent-color); margin: 10px 0; font-size: 1.4em; font-weight: 300; }
        .controls {
            display: flex; justify-content: space-between; align-items: center; padding: 8px 15px;
            flex-wrap: wrap; gap: 10px; background-color: var(--bg-tertiary-color);
            border-bottom: 1px solid var(--border-color); flex-shrink: 0;
        }
        .controls-group { display: flex; align-items: center; gap: 8px; }
        .controls button, .controls select, .controls input[type="number"] {
            padding: 6px 10px; border: 1px solid var(--border-color); border-radius: 5px;
            background-color: #424242; color: var(--text-color); cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease; font-size: 0.75em;
            font-family: "Noto Sans JP", sans-serif;
        }
        .controls button:hover, .controls select:hover, .controls input[type="number"]:hover { background-color: #4f4f4f; border-color: #5a5a5a; }
        .controls button.primary, .controls button.active-mode { 
             background-color: #95d585; 
             border-color: var(--note-color); 
             color: var(--bg-color); 
        }
        .controls button.primary:hover, .controls button.active-mode:hover { background-color: var(--note-hover-color); }
        .controls button:disabled { background-color: #2a2a2a; color: #666666; border-color: #444; cursor: not-allowed; }
        
        .controls label { margin-right: 4px; font-size: 0.85em; }
        .controls input[type="number"] { width: 35px; text-align: center; }
        .controls .tempo-control span, .instrument-control, .step-control, .loop-control { color: var(--text-color); display: flex; align-items: center; }
        #stepCountLabel {text-align: center; font-size: 0.85em; }

        .main-sequencer-area { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }

        .sequencer-wrapper { display: flex; flex-grow: 1; overflow: hidden; padding: 10px 10px 5px 10px; background-color: var(--bg-secondary-color); }
        .grid-container {
            display: grid; grid-template-columns: repeat(var(--current-num-steps, 16), var(--cell-width));
            grid-template-rows: repeat(var(--num-notes, 12), var(--cell-height)); gap: var(--grid-gap);
            position: relative; overflow: auto; flex-grow: 1; height: 100%; padding: var(--grid-gap);
            scrollbar-width: thin; scrollbar-color: #555 #333; z-index: 0;
            touch-action: none; 
        }
        .cell, .drum-cell { 
            width: var(--cell-width); height: var(--cell-height);
            cursor: pointer; transition: background-color 0.05s ease; border-radius: 3px;
            position: relative; 
            display: flex; 
            box-sizing: border-box; 
        }
        .cell { background-color: var(--cell-bg-color); z-index: 1;}
        .cell.c-octave { background-color: var(--cell-bg-c-octave-color); }
        .cell:hover { background-color: #4a4a4a; }
        .cell.c-octave:hover { background-color: color-mix(in srgb, var(--cell-bg-c-octave-color) 70%, #4a4a4a 30%); }
        .cell.playing-head, .cell.playing-head.c-octave { background-color: var(--playing-head-highlight-bg) !important; z-index: 0; }

        .sub-cell-placeholder {
            flex-grow: 1;
            height: 100%;
            box-sizing: border-box;
        }
        .cell.split > .sub-cell-placeholder:first-child,
        .drum-cell.split > .sub-cell-placeholder:first-child {
            margin-right: calc(var(--grid-gap) / 2);
        }
        .cell.split > .sub-cell-placeholder:last-child,
        .drum-cell.split > .sub-cell-placeholder:last-child {
            margin-left: calc(var(--grid-gap) / 2);
        }
        .drum-cell.split { 
             border: 1px solid var(--border-color); 
        }


        .note-block-layer { position: absolute; top: var(--grid-gap); left: var(--grid-gap); width: 100%; height: 100%; pointer-events: none; z-index: 2; overflow: visible; }
        .note-block {
            position: absolute; height: var(--cell-height); background: radial-gradient(#aaee99, #66bb6a);
            border-radius: 3px; box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            transition: background-color 0.1s ease, width 0.05s ease, left 0.05s ease;
            box-sizing: border-box;
        }
        .note-block:hover { background-color: var(--note-hover-color); }

        .drum-sequencer-wrapper {
            display: flex; padding: 5px 10px 10px 10px;
            background-color: var(--bg-tertiary-color);
            border-top: 1px solid var(--border-color);
            flex-shrink: 0; 
        }
        .drum-labels-container { display: none; }

        .drum-grid-container {
            display: grid;
            grid-template-columns: repeat(var(--current-num-steps, 16), var(--cell-width));
            grid-template-rows: repeat(var(--num-drum-tracks, 3), var(--cell-height));
            gap: var(--grid-gap);
            overflow-x: hidden; overflow-y: hidden;
            padding: var(--grid-gap);
            scrollbar-width: none; -ms-overflow-style: none; 
            position: relative; 
        }
        .drum-grid-container::-webkit-scrollbar { display: none; }

        .drum-cell {
            background-color: var(--drum-cell-bg-color); 
            border: 1px solid var(--border-color); 
        }
        .drum-cell:hover { background-color: var(--drum-cell-hover-color); } 
        .drum-cell.active:not(.split) { background: radial-gradient(#aaee99, #66bb6a); } 
        .drum-cell.active:not(.split):hover { background-color: var(--drum-cell-active-hover-color); } 
        
        .drum-cell .sub-drum-active {
            position: absolute; top:0; height: 100%;
            background: radial-gradient(#aaee99, #66bb6a);
            border-radius: 2px; 
            box-sizing: border-box;
        }
        .drum-cell.split .sub-drum-active.sub-0 { 
            left: 0; 
            width: calc(var(--cell-width)/2 - var(--grid-gap)/2); 
        }
        .drum-cell.split .sub-drum-active.sub-1 { 
            right: 0; 
            width: calc(var(--cell-width)/2 - var(--grid-gap)/2); 
        }

        .drum-cell.playing-head { background-color: var(--playing-head-highlight-bg) !important; }
        .drum-cell.active:not(.split).playing-head { 
            background-color: color-mix(in srgb, var(--drum-cell-active-color) 60%, var(--playing-head-highlight-bg) 40%) !important;
        }
        .drum-cell.playing-head .sub-drum-active { 
             background-color: color-mix(in srgb, var(--drum-cell-active-color) 60%, var(--playing-head-highlight-bg) 40%) !important;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Concellt - MIDI Sequencer</h1>
        <div class="controls">
            <div class="controls-group">
                <button id="playBtn" class="primary">▶</button>
                <button id="stopBtn" disabled>■</button>
                <button id="undoBtn" title="Undo (Ctrl+Z)" disabled>←</button>
                <button id="redoBtn" title="Redo (Ctrl+Y)" disabled>→</button>
            </div>
            <div class="controls-group">
                <div class="tempo-control">
                    <input type="number" id="tempo" value="120" min="20" max="600">
                </div>
                <div class="instrument-control">
                    <select id="instrumentSelect">
                        <option value="piano">Synth</option>
                        <option value="filteredSaw">Saw</option>
                        <option value="pluck">Pluck</option>
                        <option value="guitar">String</option>
                        <option value="violin">Violin</option>
                        <option value="brass">Brass</option>
                        <option value="woodwind">Wood</option>
                        <option value="xylophone">Xylo</option>
                        <option value="sine">Sine</option>
                        <option value="triangle">Tri</option>
                    </select>
                </div>
                 <div class="step-control">
                </div>
            </div>
            <div class="controls-group">
                    <span id="stepCountLabel">16</span>
                    <button id="addStepBtn" title="Add Step">＋</button>
                    <button id="removeStepBtn" title="Remove Last Step">―</button>
                <button id="duplicateAppendBtn" title="Duplicate and Append">×</button>
                <button id="splitCellBtn" title="Cell Division Mode">÷</button>
                <button id="sustainNoteBtn" title="Sustain Mode" style="font-family:'Noto Sans Math'">↦</button>
                <button id="loopBtn" title="Loop Mode" style="font-family:'Noto Sans Math'">↺</button>
                <button id="clearBtn" title="Clear">／</button>
            </div>
            <div class="controls-group">
                <button id="exportWavBtn">↓</button>
            </div>
        </div>

        <div class="main-sequencer-area">
            <div class="sequencer-wrapper">
                <div class="grid-container">
                    <div class="note-block-layer"></div>
                </div>
            </div>
            <div class="drum-sequencer-wrapper">
                <div class="drum-labels-container"></div>
                <div class="drum-grid-container"></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const START_OCTAVE = 2; const NUM_OCTAVES = 5;
            const ALL_NOTE_NAMES_IN_OCTAVE = ["B", "A#", "A", "G#", "G", "F#", "F", "E", "D#", "D", "C#", "C"];
            let NUM_NOTES = NUM_OCTAVES * 12; let NOTE_NAMES = []; let BASE_MIDI_NOTE; 
            const initialNumSteps = 16;
            const cellWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-width'));
            const cellHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-height'));
            const gridGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap'));

            const NUM_DRUM_TRACKS = 3;
            const DRUM_TRACK_NAMES = ["Finger Snap", "Hi-Hat", "Kick"]; 
            document.documentElement.style.setProperty('--num-drum-tracks', NUM_DRUM_TRACKS);

            const gridContainer = document.querySelector('.grid-container');
            const noteBlockLayer = gridContainer.querySelector('.note-block-layer');
            const drumLabelsContainer = document.querySelector('.drum-labels-container');
            const drumGridContainer = document.querySelector('.drum-grid-container');

            const playBtn = document.getElementById('playBtn'); const stopBtn = document.getElementById('stopBtn');
            const clearBtn = document.getElementById('clearBtn'); const tempoInput = document.getElementById('tempo');
            const instrumentSelect = document.getElementById('instrumentSelect');
            const addStepBtn = document.getElementById('addStepBtn'); const removeStepBtn = document.getElementById('removeStepBtn');
            const stepCountLabel = document.getElementById('stepCountLabel');
            const loopBtn = document.getElementById('loopBtn'); 
            const duplicateAppendBtn = document.getElementById('duplicateAppendBtn');
            const exportWavBtn = document.getElementById('exportWavBtn');
            const splitCellBtn = document.getElementById('splitCellBtn'); 
            const sustainNoteBtn = document.getElementById('sustainNoteBtn'); // MODIFIED: Added sustain button reference
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');

            let audioContext; 
            let notesData = []; 
            let drumNotesData = []; 
            let currentStep = 0; let isPlaying = false;
            let intervalId = null; let tempoBPM = 120;
            let currentNumSteps = initialNumSteps; let shouldLoop = true; 
            let draggingNoteInfo = null; let activeAudioNodes = {};
            let activeDrumAudioNodes = {}; 
            let isSplitCellMode = false; 
            let isSustainNoteMode = false; // MODIFIED: Added sustain mode state, default off

            let undoStack = [];
            let redoStack = [];
            const MAX_HISTORY_SIZE = 50;

            let noteInteractionDebounceTimer = null;
            let drumInteractionDebounceTimer = null;
            const TOUCH_DEBOUNCE_DELAY = 50; 
            let isLikelyTap = false;

            function generateNoteNamesAndBaseMidi() { 
                NOTE_NAMES = []; const topOctave = START_OCTAVE + NUM_OCTAVES - 1; 
                for (let oct = topOctave; oct >= START_OCTAVE; oct--) { 
                    ALL_NOTE_NAMES_IN_OCTAVE.forEach(nameBase => NOTE_NAMES.push(nameBase + oct)); 
                } 
                const topNoteName = NOTE_NAMES[0]; const topNoteLetter = topNoteName.replace(/[0-9]/g, ''); 
                const topOctaveNum = parseInt(topNoteName.replace(/\D/g, '')); 
                const midiOffset = { "C":0, "C#":1, "D":2, "D#":3, "E":4, "F":5, "F#":6, "G":7, "G#":8, "A":9, "A#":10, "B":11 }; 
                BASE_MIDI_NOTE = (topOctaveNum + 1) * 12 + midiOffset[topNoteLetter];
            }
            function initAudioContext() { 
                if (!audioContext) { 
                    try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); } 
                    catch (e) { alert('Web Audio API is not supported.'); return false; } 
                } 
                if (audioContext.state === 'suspended') { 
                    audioContext.resume().catch(err => console.error("AudioContext resume failed:", err)); 
                } 
                return true;
            }
            
            function createDefaultMelodyCellData() { return { isSplit: false, noteInfo: null }; }
            function createDefaultDrumCellData() { return { isSplit: false, active: false }; }

            function initializeGridStructure() {
                Array.from(gridContainer.children).forEach(child => { 
                    if (!child.classList.contains('note-block-layer')) child.remove(); 
                });

                gridContainer.style.setProperty('--current-num-steps', currentNumSteps);
                gridContainer.style.setProperty('--num-notes', NUM_NOTES);

                for (let note = 0; note < NUM_NOTES; note++) {
                    for (let step = 0; step < currentNumSteps; step++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell'); 
                        cell.dataset.step = step; 
                        cell.dataset.note = note;
                        
                        const subCellPlaceholder1 = document.createElement('div'); 
                        subCellPlaceholder1.classList.add('sub-cell-placeholder', 'sub-0');
                        const subCellPlaceholder2 = document.createElement('div'); 
                        subCellPlaceholder2.classList.add('sub-cell-placeholder', 'sub-1');
                        cell.appendChild(subCellPlaceholder1); 
                        cell.appendChild(subCellPlaceholder2);

                        if (NOTE_NAMES[note].startsWith("C") && !NOTE_NAMES[note].startsWith("C#")) {
                            cell.classList.add('c-octave');
                        }
                        cell.addEventListener('mousedown', handleInteractionStart); 
                        cell.addEventListener('touchstart', handleInteractionStart, { passive: false }); 
                        gridContainer.insertBefore(cell, noteBlockLayer);
                    }
                }
            }
            
            function initializeGridData() {
                notesData = [];
                for (let note = 0; note < NUM_NOTES; note++) {
                    notesData[note] = [];
                    for (let step = 0; step < currentNumSteps; step++) {
                        notesData[note][step] = createDefaultMelodyCellData();
                    }
                }
            }

            function initializeDrumGridStructure() {
                drumGridContainer.innerHTML = ''; 
                drumLabelsContainer.innerHTML = '';

                drumGridContainer.style.setProperty('--current-num-steps', currentNumSteps);

                for (let track = 0; track < NUM_DRUM_TRACKS; track++) {
                    for (let step = 0; step < currentNumSteps; step++) {
                        const cell = document.createElement('div');
                        cell.classList.add('drum-cell'); 
                        cell.dataset.step = step; 
                        cell.dataset.track = track;
                        
                        const subCellPlaceholder1 = document.createElement('div'); 
                        subCellPlaceholder1.classList.add('sub-cell-placeholder', 'sub-0');
                        const subCellPlaceholder2 = document.createElement('div'); 
                        subCellPlaceholder2.classList.add('sub-cell-placeholder', 'sub-1');
                        cell.appendChild(subCellPlaceholder1); 
                        cell.appendChild(subCellPlaceholder2);
                        
                        cell.addEventListener('mousedown', handleDrumInteraction); 
                        cell.addEventListener('touchstart', handleDrumInteraction, { passive: false }); 
                        drumGridContainer.appendChild(cell);
                    }
                }
            }

            function initializeDrumGridData() {
                drumNotesData = [];
                for (let track = 0; track < NUM_DRUM_TRACKS; track++) {
                    drumNotesData[track] = [];
                    for (let step = 0; step < currentNumSteps; step++) {
                        drumNotesData[track][step] = createDefaultDrumCellData();
                    }
                }
            }
            
            function init() { 
                generateNoteNamesAndBaseMidi(); 
                tempoBPM = parseInt(tempoInput.value); 
                if (shouldLoop) {
                    loopBtn.classList.add('active-mode');
                } else {
                    loopBtn.classList.remove('active-mode');
                }
                // Sustain note button is off by default, no class needed initially
                isSustainNoteMode = false;
                sustainNoteBtn.classList.remove('active-mode');


                currentNumSteps = initialNumSteps;

                initializeGridStructure(); 
                initializeGridData();      
                renderNotes();             

                initializeDrumGridStructure(); 
                initializeDrumGridData();        
                renderDrumNotes();               
                
                stepCountLabel.textContent = `${currentNumSteps}`; 
                updateRemoveStepButtonState();
                saveStateForUndo(true); 
                updateUndoRedoButtons();

                setAppHeight();
            }

            function renderNotes() { 
                noteBlockLayer.innerHTML = ''; 
                gridContainer.querySelectorAll('.cell').forEach(domCell => {
                    const note = parseInt(domCell.dataset.note); 
                    const step = parseInt(domCell.dataset.step);
                    if (notesData[note] && notesData[note][step]) { 
                       domCell.classList.toggle('split', notesData[note][step].isSplit);
                    } else {
                       domCell.classList.remove('split'); 
                    }
                });

                for (let note = 0; note < NUM_NOTES; note++) {
                     if (!notesData[note]) continue; 
                    for (let step = 0; step < currentNumSteps; step++) {
                        if (!notesData[note][step]) continue; 
                        const cellData = notesData[note][step];
                        if (cellData.isSplit) {
                            if (cellData.subNotes) {
                                for (let sub = 0; sub < 2; sub++) {
                                    const subNoteEvent = cellData.subNotes[sub];
                                    if (subNoteEvent && subNoteEvent.duration > 0) {
                                        const noteBlock = document.createElement('div');
                                        noteBlock.classList.add('note-block');
                                        noteBlock.dataset.note = note; 
                                        noteBlock.dataset.step = step; 
                                        noteBlock.dataset.sub = sub;
                                        noteBlock.style.top = `${note * (cellHeight + gridGap)}px`;
                                        
                                        const noteStartPixelOffset = (step * (cellWidth + gridGap)) + (sub * (cellWidth / 2 + gridGap / 2));
                                        noteBlock.style.left = `${noteStartPixelOffset}px`;
                                        
                                        let calculatedWidthPx = 0;
                                        let remainingDurationInSubSteps = subNoteEvent.duration * 2; 
                                        let currentDrawingStep = step;
                                        let currentDrawingSubStep = sub;

                                        while(remainingDurationInSubSteps > 0 && currentDrawingStep < currentNumSteps) {
                                            const cellForWidthCalc = (notesData[note] && notesData[note][currentDrawingStep]) ? notesData[note][currentDrawingStep] : createDefaultMelodyCellData();
                                            if (cellForWidthCalc.isSplit) {
                                                if (currentDrawingSubStep === 0) {
                                                    calculatedWidthPx += (cellWidth/2);
                                                    remainingDurationInSubSteps--;
                                                    if (remainingDurationInSubSteps > 0) { 
                                                       calculatedWidthPx += (gridGap/2);
                                                    }
                                                    currentDrawingSubStep = 1;
                                                } else { 
                                                    calculatedWidthPx += (cellWidth/2);
                                                    remainingDurationInSubSteps--;
                                                    if (remainingDurationInSubSteps > 0) { 
                                                        calculatedWidthPx += gridGap;
                                                    }
                                                    currentDrawingStep++;
                                                    currentDrawingSubStep = 0;
                                                }
                                            } else { 
                                                calculatedWidthPx += cellWidth;
                                                remainingDurationInSubSteps -=2;
                                                if (remainingDurationInSubSteps > 0) {
                                                    calculatedWidthPx += gridGap;
                                                }
                                                currentDrawingStep++;
                                                currentDrawingSubStep = 0; 
                                            }
                                            if (subNoteEvent.duration === 0.5 && currentDrawingStep === step && currentDrawingSubStep === (sub === 0 ? 1: 0 )) {
                                                if(sub === 0 && calculatedWidthPx > (cellWidth/2)) calculatedWidthPx -= (gridGap/2);
                                            }
                                        }
                                        noteBlock.style.width = `${calculatedWidthPx}px`;
                                        noteBlockLayer.appendChild(noteBlock);
                                    }
                                }
                            }
                        } else if (cellData.noteInfo && cellData.noteInfo.duration > 0) {
                            const noteEvent = cellData.noteInfo;
                            const noteBlock = document.createElement('div'); 
                            noteBlock.classList.add('note-block');
                            noteBlock.dataset.note = note; 
                            noteBlock.dataset.step = step;
                            noteBlock.style.top = `${note * (cellHeight + gridGap)}px`;
                            noteBlock.style.left = `${step * (cellWidth + gridGap)}px`;
                            noteBlock.style.width = `${(noteEvent.duration * cellWidth) + ((noteEvent.duration - 1) * gridGap)}px`;
                            noteBlockLayer.appendChild(noteBlock);
                        }
                    }
                }
                highlightCurrentStepColumn(); 
            }

            function renderDrumNotes() { 
                drumGridContainer.querySelectorAll('.drum-cell').forEach(domCell => {
                    const track = parseInt(domCell.dataset.track); 
                    const step = parseInt(domCell.dataset.step);
                    if (drumNotesData[track] && drumNotesData[track][step]) { 
                        domCell.classList.toggle('split', drumNotesData[track][step].isSplit); 
                    } else { 
                        domCell.classList.remove('split'); 
                    }
                });
                drumGridContainer.querySelectorAll('.sub-drum-active').forEach(sub => sub.remove());
                for (let track = 0; track < NUM_DRUM_TRACKS; track++) {
                    if (!drumNotesData[track]) continue;
                    for (let step = 0; step < currentNumSteps; step++) {
                        if (!drumNotesData[track][step]) continue;
                        const cell = drumGridContainer.querySelector(`.drum-cell[data-track="${track}"][data-step="${step}"]`);
                        if (!cell) continue; 
                        const cellData = drumNotesData[track][step]; 
                        cell.classList.remove('active'); 
                        if (cellData.isSplit) { 
                            if (cellData.subActive) { 
                                if (cellData.subActive[0]) { 
                                    const subActiveEl = document.createElement('div'); 
                                    subActiveEl.classList.add('sub-drum-active', 'sub-0'); 
                                    cell.appendChild(subActiveEl); 
                                } 
                                if (cellData.subActive[1]) { 
                                    const subActiveEl = document.createElement('div'); 
                                    subActiveEl.classList.add('sub-drum-active', 'sub-1'); 
                                    cell.appendChild(subActiveEl); 
                                }
                            }
                        } else { 
                            if (cellData.active) { 
                                cell.classList.add('active'); 
                            }
                        }
                    }
                }
                highlightCurrentStepColumn(); 
            }

            function highlightCurrentStepColumn() { 
                gridContainer.querySelectorAll('.cell.playing-head').forEach(c => c.classList.remove('playing-head')); 
                if (isPlaying && currentStep >= 0 && currentStep < currentNumSteps) { 
                    for (let note = 0; note < NUM_NOTES; note++) { 
                        const cell = gridContainer.querySelector(`.cell[data-note="${note}"][data-step="${currentStep}"]`); 
                        if (cell) cell.classList.add('playing-head'); 
                    }
                }
                drumGridContainer.querySelectorAll('.drum-cell.playing-head').forEach(c => c.classList.remove('playing-head')); 
                if (isPlaying && currentStep >= 0 && currentStep < currentNumSteps) { 
                    for (let track = 0; track < NUM_DRUM_TRACKS; track++) { 
                        const cell = drumGridContainer.querySelector(`.drum-cell[data-track="${track}"][data-step="${currentStep}"]`); 
                        if (cell) cell.classList.add('playing-head'); 
                    }
                }
            }
            
            function getSubStepFromMouseEvent(event, targetCell) { 
                const cellRect = targetCell.getBoundingClientRect(); 
                const clientX = event.type.startsWith('touch') ? event.touches[0].clientX : event.clientX; 
                const offsetXInCell = clientX - cellRect.left;
                if (targetCell.classList.contains('split')) { 
                    return offsetXInCell < (cellRect.width / 2 - gridGap / 4) ? 0 : 1; 
                } 
                return offsetXInCell < cellRect.width / 2 ? 0 : 1;
            }

            function shallowCloneTouchEvent(event) {
                if (event.type.startsWith('touch') && event.touches && event.touches.length > 0) {
                    return {
                        type: event.type,
                        target: event.target,
                        touches: [{ clientX: event.touches[0].clientX, clientY: event.touches[0].clientY }],
                        originalDataset: event.target.closest('.cell, .drum-cell')?.dataset 
                    };
                }
                return { 
                    type: event.type,
                    target: event.target,
                    clientX: event.clientX,
                    clientY: event.clientY,
                    button: event.button,
                    originalDataset: event.target.closest('.cell, .drum-cell')?.dataset
                };
            }

            function handleInteractionStart(event) {
                isLikelyTap = false; 
                if (event.type.startsWith('touch')) {
                    if (event.touches.length > 1) {
                        if (noteInteractionDebounceTimer) {
                            clearTimeout(noteInteractionDebounceTimer);
                            noteInteractionDebounceTimer = null;
                        }
                        return; 
                    }
                    event.preventDefault(); 
                    isLikelyTap = true; 

                    if (noteInteractionDebounceTimer) {
                        clearTimeout(noteInteractionDebounceTimer);
                    }
                    const eventCopy = shallowCloneTouchEvent(event);
                    noteInteractionDebounceTimer = setTimeout(() => {
                        noteInteractionDebounceTimer = null;
                        if (gridTouchState.isPanning) return; 
                        _executeInteractionStart(eventCopy);
                    }, TOUCH_DEBOUNCE_DELAY);
                    return; 
                }
                _executeInteractionStart(event);
            }
            
            function _executeInteractionStart(event) { 
                if (event.type.startsWith('touch') && draggingNoteInfo && draggingNoteInfo.isTouch) {
                    draggingNoteInfo = null;
                }

                if (event.type === 'mousedown' && event.button !== 0) return; 
                if (!initAudioContext()) return;

                const datasetSource = event.originalDataset || event.target.closest('.cell')?.dataset;
                const targetDomCell = event.target.closest('.cell'); 

                if (!targetDomCell || !datasetSource) return;

                const step = parseInt(datasetSource.step); 
                const note = parseInt(datasetSource.note);

                if (isNaN(note) || isNaN(step) || !notesData[note] || !notesData[note][step]) return; 
                const cellData = notesData[note][step]; 
                const clientX = event.type.startsWith('touch') ? event.touches[0].clientX : event.clientX;

                if (isSplitCellMode) {
                    if (!cellData.isSplit) {
                        cellData.isSplit = true; 
                        targetDomCell.classList.add('split'); 

                        const existingNoteInfo = cellData.noteInfo;
                        cellData.subNotes = [null, null]; 
                        if (existingNoteInfo && existingNoteInfo.duration > 0) {
                            cellData.subNotes[0] = { duration: 0.5 }; 
                            if (existingNoteInfo.duration > 0.5) { 
                                cellData.subNotes[1] = { duration: existingNoteInfo.duration - 0.5 };
                            } else {
                                cellData.subNotes[1] = { duration: 0.5 }; 
                            }
                        }
                        delete cellData.noteInfo; 
                        if (cellData.subNotes[0]) playNoteSound(note, 0.05, audioContext.currentTime, `splitclick-${note}-${step}-0`, audioContext);
                        if (cellData.subNotes[1]) playNoteSound(note, 0.05, audioContext.currentTime + 0.01, `splitclick-${note}-${step}-1`, audioContext);
                        renderNotes();
                        saveStateForUndo();
                    }
                    isSplitCellMode = false; 
                    splitCellBtn.classList.remove('active-mode');
                    gridContainer.style.cursor = 'default'; 
                    drumGridContainer.style.cursor = 'default';
                    return;
                }

                const subStepIndex = cellData.isSplit ? getSubStepFromMouseEvent(event, targetDomCell) : -1;
                const currentIsTouch = event.type.startsWith('touch');

                if (cellData.isSplit) { 
                    if (!cellData.subNotes) cellData.subNotes = [null, null]; 
                    let subNoteToDrag = cellData.subNotes[subStepIndex];
                    if (subNoteToDrag) { 
                        draggingNoteInfo = { 
                            note: note, startStep: step, subStep: subStepIndex, 
                            originalDuration: subNoteToDrag.duration, action: 'maybe_drag_or_delete_sub', 
                            initialClientX: clientX, 
                            initialOffsetXFromNoteStart: clientX - (targetDomCell.getBoundingClientRect().left + (subStepIndex * (cellWidth/2 + gridGap/2))),
                            isTouch: currentIsTouch 
                        };
                    } else { 
                        cellData.subNotes[subStepIndex] = { duration: 0.5 }; 
                        playNoteSound(note, 0.05, audioContext.currentTime, `click-${note}-${step}-${subStepIndex}`, audioContext);
                        draggingNoteInfo = { 
                            note: note, startStep: step, subStep: subStepIndex, 
                            originalDuration: 0, action: 'create_drag_sub', 
                            initialClientX: clientX, 
                            initialOffsetXFromNoteStart: clientX - (targetDomCell.getBoundingClientRect().left + (subStepIndex * (cellWidth/2 + gridGap/2))),
                            isTouch: currentIsTouch 
                        }; 
                    }
                } else { 
                    let existingNoteStartStep = -1; 
                    let existingNoteObject = null; 
                    if (cellData.noteInfo && cellData.noteInfo.duration > 0) { 
                        existingNoteStartStep = step; 
                        existingNoteObject = cellData.noteInfo; 
                    } else { 
                        for (let s = step - 1; s >= 0; s--) { 
                             if (!notesData[note] || !notesData[note][s]) break;
                            const prevCellData = notesData[note][s]; 
                            if (prevCellData && !prevCellData.isSplit && prevCellData.noteInfo && prevCellData.noteInfo.duration > 0) { 
                                if (s + prevCellData.noteInfo.duration > step) { 
                                    existingNoteStartStep = s; 
                                    existingNoteObject = prevCellData.noteInfo; 
                                    break; 
                                } else { break; }
                            } else if (prevCellData && (prevCellData.isSplit || !prevCellData.noteInfo)) { break; }
                        }
                    } 
                    const cellRect = targetDomCell.getBoundingClientRect(); 
                    const offsetXInCell = clientX - cellRect.left; 
                    if (existingNoteObject) { 
                        draggingNoteInfo = { 
                            note: note, startStep: existingNoteStartStep, subStep: -1, 
                            originalDuration: existingNoteObject.duration, action: 'maybe_drag_or_delete', 
                            initialClientX: clientX, 
                            initialOffsetXFromNoteStart: (step - existingNoteStartStep) * (cellWidth + gridGap) + offsetXInCell,
                            isTouch: currentIsTouch 
                        }; 
                    } else { 
                        notesData[note][step].noteInfo = { duration: 1 }; 
                        playNoteSound(note, 0.05, audioContext.currentTime, `click-${note}-${step}`, audioContext); 
                        draggingNoteInfo = { 
                            note: note, startStep: step, subStep: -1, 
                            originalDuration: 0, 
                            action: 'create_drag', 
                            initialClientX: clientX, 
                            initialOffsetXFromNoteStart: offsetXInCell,
                            isTouch: currentIsTouch 
                        }; 
                    }
                }
                renderNotes();
                if (draggingNoteInfo) { 
                    draggingNoteInfo.initialEventType = currentIsTouch ? 'touchstart' : 'mousedown';
                    
                    if (draggingNoteInfo.initialEventType === 'mousedown') { 
                        document.addEventListener('mousemove', handleInteractionMove); 
                        document.addEventListener('mouseup', handleInteractionEnd); 
                    } else { 
                        document.addEventListener('touchmove', handleInteractionMove, { passive: false }); 
                        document.addEventListener('touchend', handleInteractionEnd); 
                        document.addEventListener('touchcancel', handleInteractionEnd); 
                    }
                }
            }


            function handleInteractionMove(event) { 
                if (!draggingNoteInfo) return; 
                if (event.type === 'touchmove') {
                    event.preventDefault();
                    isLikelyTap = false; 
                }
                const note = draggingNoteInfo.note; 
                const startStep = draggingNoteInfo.startStep; 
                const startSubStep = draggingNoteInfo.subStep;
                if (!notesData[note] || !notesData[note][startStep]) return;

                const clientX = event.type === 'touchmove' ? event.touches[0].clientX : event.clientX;
                const gridRect = gridContainer.getBoundingClientRect(); 
                const mouseXInGridContent = clientX - gridRect.left + gridContainer.scrollLeft; 
                
                let currentMouseGlobalStepFloat = mouseXInGridContent / (cellWidth + gridGap);
                let currentMouseCellIndex = Math.floor(currentMouseGlobalStepFloat);
                let fractionInCell = currentMouseGlobalStepFloat - currentMouseCellIndex;
                let currentMouseSubCellIndex = (fractionInCell * (cellWidth + gridGap) < (cellWidth / 2 + gridGap / 2)) ? 0 : 1;
                currentMouseCellIndex = Math.max(0, Math.min(currentNumSteps - 1, currentMouseCellIndex));

                if (draggingNoteInfo.action.startsWith('maybe_drag_or_delete')) {
                    if (Math.abs(clientX - draggingNoteInfo.initialClientX) > 5) { 
                        draggingNoteInfo.action = (startSubStep !== -1) ? 'drag_length_sub' : 'drag_length';
                    } else { return; } 
                }
                
                if (draggingNoteInfo.action === 'create_drag' || draggingNoteInfo.action === 'drag_length') { 
                    const noteToModify = notesData[note][startStep].noteInfo; 
                    if (noteToModify) {
                        const newDurationSteps = Math.max(1, currentMouseCellIndex - startStep + 1);
                        if (newDurationSteps !== noteToModify.duration) { 
                            // MODIFIED: Only update duration if sustain mode is active
                            if (isSustainNoteMode) {
                                noteToModify.duration = newDurationSteps; 
                                renderNotes(); 
                            }
                        }
                    }
                } else if (draggingNoteInfo.action === 'create_drag_sub' || draggingNoteInfo.action === 'drag_length_sub') { 
                    if (!notesData[note][startStep].subNotes) notesData[note][startStep].subNotes = [null, null];
                    const subNoteToModify = notesData[note][startStep].subNotes[startSubStep]; 
                    if (subNoteToModify) { 
                        let numHalfSteps = 0; 
                        if (currentMouseCellIndex > startStep) {
                            numHalfSteps = (currentMouseCellIndex - startStep) * 2; 
                            numHalfSteps += (startSubStep === 0 ? 1 : 0); 
                            numHalfSteps += (currentMouseSubCellIndex === 0 ? 1 : 2); 
                        } else if (currentMouseCellIndex === startStep) { 
                            if (currentMouseSubCellIndex >= startSubStep) { 
                                numHalfSteps = currentMouseSubCellIndex - startSubStep + 1; 
                            } else { numHalfSteps = 1; }
                        } else { numHalfSteps = 1; } 
                        const newDuration = Math.max(0.5, numHalfSteps * 0.5); 
                        if (newDuration !== subNoteToModify.duration) { 
                            // MODIFIED: Only update duration if sustain mode is active
                            if (isSustainNoteMode) {
                                subNoteToModify.duration = newDuration; 
                                renderNotes(); 
                            }
                        }
                    }
                }
            }

            function handleInteractionEnd(event) { 
                if (!draggingNoteInfo) return; 
                
                const note = draggingNoteInfo.note; 
                const step = draggingNoteInfo.startStep; 
                const subStep = draggingNoteInfo.subStep;
                const originalEventType = draggingNoteInfo.initialEventType; 

                if (originalEventType === 'mousedown') { 
                    document.removeEventListener('mousemove', handleInteractionMove); 
                    document.removeEventListener('mouseup', handleInteractionEnd); 
                } else { 
                    document.removeEventListener('touchmove', handleInteractionMove); 
                    document.removeEventListener('touchend', handleInteractionEnd); 
                    document.removeEventListener('touchcancel', handleInteractionEnd); 
                }
                
                if (!notesData[note] || !notesData[note][step]) {
                     draggingNoteInfo = null; 
                     isLikelyTap = false;
                     return;
                }

                let stateChanged = false;

                if (originalEventType === 'touchstart' && isLikelyTap) {
                    if (draggingNoteInfo.action === 'maybe_drag_or_delete') {
                        if (notesData[note][step] && !notesData[note][step].isSplit && notesData[note][step].noteInfo) {
                            notesData[note][step].noteInfo = null; 
                            stateChanged = true;
                        }
                    } else if (draggingNoteInfo.action === 'maybe_drag_or_delete_sub') {
                        if (notesData[note][step] && notesData[note][step].isSplit && notesData[note][step].subNotes && notesData[note][step].subNotes[subStep]) {
                            notesData[note][step].subNotes[subStep] = null; 
                            stateChanged = true;
                        }
                    } else if (draggingNoteInfo.action === 'create_drag' || draggingNoteInfo.action === 'create_drag_sub') {
                        stateChanged = true; 
                    }
                } else { 
                    if (draggingNoteInfo.action === 'maybe_drag_or_delete') { 
                        if (notesData[note][step] && !notesData[note][step].isSplit && notesData[note][step].noteInfo) { 
                             notesData[note][step].noteInfo = null; 
                             stateChanged = true;
                        }
                    } else if (draggingNoteInfo.action === 'maybe_drag_or_delete_sub') { 
                        if (notesData[note][step] && notesData[note][step].isSplit && notesData[note][step].subNotes && notesData[note][step].subNotes[subStep]) { 
                            notesData[note][step].subNotes[subStep] = null; 
                            stateChanged = true;
                        }
                    } else if (draggingNoteInfo.action.includes('drag') || draggingNoteInfo.action.includes('create')) {
                        // If it was a drag, length adjustment (if any) happened in handleInteractionMove
                        // (respecting isSustainNoteMode).
                        // If it was a create_drag that didn't move much, it's a single note.
                        stateChanged = true;
                    }
                }

                // Ensure final render, especially if a note was created but not dragged (or drag was no-op due to sustain mode off)
                renderNotes(); 
                if (stateChanged) {
                    saveStateForUndo();
                }
                
                draggingNoteInfo = null;
                isLikelyTap = false; 
            }


            function handleDrumInteraction(event) {
                isLikelyTap = false;
                if (event.type.startsWith('touch')) {
                    if (event.touches.length > 1) {
                        if (drumInteractionDebounceTimer) {
                            clearTimeout(drumInteractionDebounceTimer);
                            drumInteractionDebounceTimer = null;
                        }
                        return; 
                    }
                    event.preventDefault(); 
                    isLikelyTap = true;

                    if (drumInteractionDebounceTimer) {
                        clearTimeout(drumInteractionDebounceTimer);
                    }
                    const eventCopy = shallowCloneTouchEvent(event);
                    drumInteractionDebounceTimer = setTimeout(() => {
                        drumInteractionDebounceTimer = null;
                        if (gridTouchState.isPanning) return; 
                        _executeDrumInteraction(eventCopy);
                    }, TOUCH_DEBOUNCE_DELAY);
                    return; 
                }
                _executeDrumInteraction(event);
            }


            function _executeDrumInteraction(event) { 
                if (event.type === 'mousedown' && event.button !== 0) return; 
                if (!initAudioContext()) return; 

                const datasetSource = event.originalDataset || event.target.closest('.drum-cell')?.dataset;
                const targetCell = event.target.closest('.drum-cell');

                if (!targetCell || !datasetSource) return; 

                const step = parseInt(datasetSource.step); 
                const track = parseInt(datasetSource.track); 

                if (isNaN(track) || isNaN(step) || !drumNotesData[track] || !drumNotesData[track][step]) return; 
                const cellData = drumNotesData[track][step];

                if (isSplitCellMode) { 
                    if (!cellData.isSplit) { 
                        cellData.isSplit = true; 
                        targetCell.classList.add('split');
                        const existingActive = cellData.active; 
                        cellData.subActive = [false, false]; 
                        if (existingActive) { 
                            cellData.subActive[0] = true; 
                            cellData.subActive[1] = true; 
                        } 
                        delete cellData.active; 
                        if (cellData.subActive[0]) playDrumSound(track, audioContext.currentTime, `splitclick-drum-${track}-${step}-0`, audioContext);
                        if (cellData.subActive[1]) playDrumSound(track, audioContext.currentTime + 0.01, `splitclick-drum-${track}-${step}-1`, audioContext);
                        renderDrumNotes(); 
                        saveStateForUndo();
                    } 
                    isSplitCellMode = false; 
                    splitCellBtn.classList.remove('active-mode'); 
                    gridContainer.style.cursor = 'default'; 
                    drumGridContainer.style.cursor = 'default'; 
                    return; 
                }

                let changed = false;
                if (cellData.isSplit) { 
                    const subStepIndex = getSubStepFromMouseEvent(event, targetCell); 
                    if (!cellData.subActive) cellData.subActive = [false, false]; 
                    const oldVal = cellData.subActive[subStepIndex];
                    cellData.subActive[subStepIndex] = !cellData.subActive[subStepIndex]; 
                    if (cellData.subActive[subStepIndex] !== oldVal) changed = true;
                    if (cellData.subActive[subStepIndex]) { 
                        playDrumSound(track, audioContext.currentTime, `drum-click-${track}-${step}-${subStepIndex}`, audioContext); 
                    }
                } else { 
                    const oldVal = cellData.active;
                    cellData.active = !cellData.active; 
                    if (cellData.active !== oldVal) changed = true;
                    if (cellData.active) { 
                        playDrumSound(track, audioContext.currentTime, `drum-click-${track}-${step}`, audioContext); 
                    }
                }
                renderDrumNotes();
                if (changed) {
                    saveStateForUndo();
                }
                isLikelyTap = false; 
            }

            function midiToFrequency(midiNote) { return 440 * Math.pow(2, (midiNote - 69) / 12); }
            function playNoteSound(noteIndex, durationSeconds, startTime, noteKey, contextToUse = audioContext) { const currentAudioContext = contextToUse; const isOfflineContext = currentAudioContext instanceof OfflineAudioContext; if (!currentAudioContext || durationSeconds <= 0) return; const midiNote = BASE_MIDI_NOTE - noteIndex; let freq = midiToFrequency(midiNote); const selectedInstrument = instrumentSelect.value; if (!isOfflineContext && activeAudioNodes[noteKey]) { try { if (activeAudioNodes[noteKey].source && typeof activeAudioNodes[noteKey].source.stop === 'function') { activeAudioNodes[noteKey].source.stop(startTime); } activeAudioNodes[noteKey].nodes.forEach(node => { try { node.disconnect(); } catch (e) { /* ignore */ } }); } catch(e) { console.warn("Error stopping previous note for replacement:", e); } delete activeAudioNodes[noteKey]; } let masterGain = currentAudioContext.createGain(); masterGain.connect(currentAudioContext.destination); let nodesToStore = [masterGain]; let mainOscillator; let longestSoundDuration = durationSeconds; const scheduledStopTime = startTime + durationSeconds; const attackTime = 0.01, releaseTime = 0.05, sustainLevel = 0.7; masterGain.gain.setValueAtTime(0, startTime); switch (selectedInstrument) { case "sine": case "triangle": mainOscillator = currentAudioContext.createOscillator(); mainOscillator.type = selectedInstrument; mainOscillator.frequency.setValueAtTime(freq, startTime); mainOscillator.connect(masterGain); nodesToStore.unshift(mainOscillator); masterGain.gain.linearRampToValueAtTime(sustainLevel, startTime + attackTime); if (durationSeconds > releaseTime) { masterGain.gain.setValueAtTime(sustainLevel, scheduledStopTime - releaseTime); masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } else { masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } longestSoundDuration = durationSeconds; break; case "piano": let osc1P = currentAudioContext.createOscillator(); osc1P.type = 'triangle'; osc1P.frequency.setValueAtTime(freq, startTime); osc1P.connect(masterGain); nodesToStore.unshift(osc1P); mainOscillator = osc1P; let osc2P = currentAudioContext.createOscillator(); osc2P.type = 'sine'; osc2P.frequency.setValueAtTime(freq * 2, startTime); let gain2P = currentAudioContext.createGain(); gain2P.gain.value = 0.4; osc2P.connect(gain2P).connect(masterGain); nodesToStore.unshift(osc2P, gain2P); osc2P.start(startTime); osc2P.stop(scheduledStopTime + 0.1); const pianoAttack = 0.005; const pianoDecay = durationSeconds * 0.8; const pianoSustain = 0.1; const pianoRelease = 0.2; masterGain.gain.linearRampToValueAtTime(0.6, startTime + pianoAttack); masterGain.gain.exponentialRampToValueAtTime(pianoSustain, startTime + pianoAttack + pianoDecay); if (durationSeconds > pianoRelease) { masterGain.gain.setValueAtTime(pianoSustain, scheduledStopTime - pianoRelease); masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } else { masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } longestSoundDuration = durationSeconds + Math.max(0.1, pianoRelease); break; case "guitar": mainOscillator = currentAudioContext.createOscillator(); mainOscillator.type = 'sawtooth'; mainOscillator.frequency.setValueAtTime(freq, startTime); let filterG = currentAudioContext.createBiquadFilter(); filterG.type = 'lowpass'; filterG.frequency.setValueAtTime(freq * 5, startTime); filterG.frequency.exponentialRampToValueAtTime(freq * 1.5, startTime + durationSeconds * 0.6); filterG.Q.value = 1; mainOscillator.connect(filterG).connect(masterGain); nodesToStore.unshift(mainOscillator, filterG); const guitarAttack = 0.002; const guitarDecay = Math.min(0.3, durationSeconds * 0.7); masterGain.gain.linearRampToValueAtTime(0.5, startTime + guitarAttack); masterGain.gain.exponentialRampToValueAtTime(0.0001, startTime + guitarAttack + guitarDecay); longestSoundDuration = guitarAttack + guitarDecay + 0.05; break; case "violin": mainOscillator = currentAudioContext.createOscillator(); mainOscillator.type = 'sawtooth'; mainOscillator.frequency.setValueAtTime(freq, startTime); mainOscillator.connect(masterGain); nodesToStore.unshift(mainOscillator); let lfoV = currentAudioContext.createOscillator(); lfoV.type = 'sine'; lfoV.frequency.setValueAtTime(5, startTime); let lfoGainV = currentAudioContext.createGain(); lfoGainV.gain.setValueAtTime(freq * 0.02, startTime); lfoV.connect(lfoGainV).connect(mainOscillator.frequency); nodesToStore.unshift(lfoV, lfoGainV); lfoV.start(startTime); lfoV.stop(scheduledStopTime + 0.1); const violinAttack = 0.05; const violinRelease = 0.1; masterGain.gain.linearRampToValueAtTime(sustainLevel * 0.8, startTime + violinAttack); if (durationSeconds > violinRelease) { masterGain.gain.setValueAtTime(sustainLevel * 0.8, scheduledStopTime - violinRelease); masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } else { masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } longestSoundDuration = durationSeconds + Math.max(0.1, violinRelease); break; case "brass": mainOscillator = currentAudioContext.createOscillator(); mainOscillator.type = 'sawtooth'; mainOscillator.frequency.setValueAtTime(freq, startTime); let filterB = currentAudioContext.createBiquadFilter(); filterB.type = 'lowpass'; filterB.frequency.setValueAtTime(freq * 1.5, startTime); filterB.frequency.linearRampToValueAtTime(freq * 6, startTime + 0.05); filterB.frequency.exponentialRampToValueAtTime(freq * 2.5, startTime + durationSeconds * 0.6); filterB.Q.value = 2; mainOscillator.connect(filterB).connect(masterGain); nodesToStore.unshift(mainOscillator, filterB); const brassAttack = 0.03; masterGain.gain.linearRampToValueAtTime(sustainLevel, startTime + brassAttack); if (durationSeconds > releaseTime) { masterGain.gain.setValueAtTime(sustainLevel, scheduledStopTime - releaseTime); masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } else { masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } longestSoundDuration = durationSeconds; break; case "woodwind": mainOscillator = currentAudioContext.createOscillator(); mainOscillator.type = 'triangle'; mainOscillator.frequency.setValueAtTime(freq, startTime); mainOscillator.connect(masterGain); nodesToStore.unshift(mainOscillator); let noiseW = currentAudioContext.createBufferSource(); let bufferSizeW = currentAudioContext.sampleRate * 0.1; let bufferW = currentAudioContext.createBuffer(1, bufferSizeW, currentAudioContext.sampleRate); let dataW = bufferW.getChannelData(0); for (let i = 0; i < bufferSizeW; i++) dataW[i] = Math.random() * 2 - 1; noiseW.buffer = bufferW; noiseW.loop = true; let noiseGainW = currentAudioContext.createGain(); noiseGainW.gain.value = 0.03; noiseW.connect(noiseGainW).connect(masterGain); nodesToStore.unshift(noiseW, noiseGainW); noiseW.start(startTime); noiseW.stop(scheduledStopTime + 0.05); const woodwindAttack = 0.04; const woodwindRelease = 0.08; masterGain.gain.linearRampToValueAtTime(sustainLevel * 0.9, startTime + woodwindAttack); if (durationSeconds > woodwindRelease) { masterGain.gain.setValueAtTime(sustainLevel * 0.9, scheduledStopTime - woodwindRelease); masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } else { masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } longestSoundDuration = durationSeconds + Math.max(0.05, woodwindRelease); break; case "xylophone": mainOscillator = currentAudioContext.createOscillator(); mainOscillator.type = 'sine'; mainOscillator.frequency.setValueAtTime(freq, startTime); mainOscillator.connect(masterGain); nodesToStore.unshift(mainOscillator); let oscX2 = currentAudioContext.createOscillator(); oscX2.type = 'sine'; oscX2.frequency.setValueAtTime(freq * 2.02, startTime); let gainX2 = currentAudioContext.createGain(); gainX2.gain.value = 0.3; oscX2.connect(gainX2).connect(masterGain); nodesToStore.unshift(oscX2, gainX2); oscX2.start(startTime); const x_secondary_decay = 0.3; oscX2.stop(startTime + x_secondary_decay); const woodAttack = 0.002; const woodDecay = 0.15; masterGain.gain.linearRampToValueAtTime(0.6, startTime + woodAttack); masterGain.gain.exponentialRampToValueAtTime(0.0001, startTime + woodAttack + woodDecay); longestSoundDuration = Math.max(woodAttack + woodDecay, x_secondary_decay) + 0.05; break; case "pluck": mainOscillator = currentAudioContext.createOscillator(); mainOscillator.type = 'triangle'; mainOscillator.frequency.setValueAtTime(freq, startTime); mainOscillator.connect(masterGain); nodesToStore.unshift(mainOscillator); const pluckAttackSimple = 0.001; const pluckDecaySimple = Math.min(0.1, durationSeconds * 0.5); masterGain.gain.linearRampToValueAtTime(0.4, startTime + pluckAttackSimple); masterGain.gain.exponentialRampToValueAtTime(0.0001, startTime + pluckAttackSimple + pluckDecaySimple); longestSoundDuration = pluckAttackSimple + pluckDecaySimple + 0.05; break; case "filteredSaw": mainOscillator = currentAudioContext.createOscillator(); mainOscillator.type = 'sawtooth'; mainOscillator.frequency.setValueAtTime(freq, startTime); let filterFS = currentAudioContext.createBiquadFilter(); filterFS.type = 'lowpass'; filterFS.frequency.setValueAtTime(freq * 0.5, startTime); filterFS.frequency.linearRampToValueAtTime(freq * 8, startTime + 0.03); filterFS.frequency.exponentialRampToValueAtTime(freq * 1.5, startTime + Math.min(0.5, durationSeconds * 0.7)); filterFS.Q.value = 3; mainOscillator.connect(filterFS).connect(masterGain); nodesToStore.unshift(mainOscillator, filterFS); const fsAttack = 0.02; const fsRelease = 0.1; masterGain.gain.linearRampToValueAtTime(sustainLevel * 0.7, startTime + fsAttack); if (durationSeconds > fsRelease) { masterGain.gain.setValueAtTime(sustainLevel * 0.7, scheduledStopTime - fsRelease); masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } else { masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } longestSoundDuration = durationSeconds + fsRelease; break; default: mainOscillator = currentAudioContext.createOscillator(); mainOscillator.type = 'sine'; mainOscillator.frequency.setValueAtTime(freq, startTime); mainOscillator.connect(masterGain); nodesToStore.unshift(mainOscillator); masterGain.gain.linearRampToValueAtTime(sustainLevel, startTime + attackTime); if (durationSeconds > releaseTime) { masterGain.gain.setValueAtTime(sustainLevel, scheduledStopTime - releaseTime); masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } else { masterGain.gain.linearRampToValueAtTime(0.00001, scheduledStopTime); } longestSoundDuration = durationSeconds; break; } if (mainOscillator) { mainOscillator.start(startTime); const effectiveStopTime = startTime + longestSoundDuration + 0.05; mainOscillator.stop(effectiveStopTime); if (!isOfflineContext) { activeAudioNodes[noteKey] = { source: mainOscillator, nodes: nodesToStore, masterGain: masterGain, expectedEndTime: effectiveStopTime }; mainOscillator.onended = () => { if (activeAudioNodes[noteKey] && activeAudioNodes[noteKey].source === mainOscillator && currentAudioContext.currentTime >= activeAudioNodes[noteKey].expectedEndTime - 0.02  ) { activeAudioNodes[noteKey].nodes.forEach(node => { try { node.disconnect(); } catch(e){ /* ignore */ } }); delete activeAudioNodes[noteKey]; } else if (activeAudioNodes[noteKey] && activeAudioNodes[noteKey].source === mainOscillator) { const remainingTime = Math.max(0, activeAudioNodes[noteKey].expectedEndTime - currentAudioContext.currentTime); setTimeout(() => { if (activeAudioNodes[noteKey] && activeAudioNodes[noteKey].source === mainOscillator) { activeAudioNodes[noteKey].nodes.forEach(node => { try { node.disconnect(); } catch(e){ /* ignore */ } }); delete activeAudioNodes[noteKey]; }}, remainingTime * 1000 + 50); }}; } }}
            function playDrumSound(trackIndex, startTime, drumKey, contextToUse = audioContext) { const currentAudioContext = contextToUse; const isOfflineContext = currentAudioContext instanceof OfflineAudioContext; let source, gain, filter; let duration = 0.15; if (!isOfflineContext && activeDrumAudioNodes[drumKey]) { try { if (activeDrumAudioNodes[drumKey].source && typeof activeDrumAudioNodes[drumKey].source.stop === 'function') { activeDrumAudioNodes[drumKey].source.stop(startTime); } if(activeDrumAudioNodes[drumKey].gain) activeDrumAudioNodes[drumKey].gain.disconnect(); if(activeDrumAudioNodes[drumKey].filter) activeDrumAudioNodes[drumKey].filter.disconnect(); } catch (e) { console.warn("Error stopping previous drum sound:", e); } delete activeDrumAudioNodes[drumKey]; } gain = currentAudioContext.createGain(); gain.connect(currentAudioContext.destination); const drumType = DRUM_TRACK_NAMES[trackIndex]; switch (drumType) { case "Finger Snap": source = currentAudioContext.createBufferSource(); const fsBufferSize = currentAudioContext.sampleRate * 0.2; const fsNoiseBuffer = currentAudioContext.createBuffer(1, fsBufferSize, currentAudioContext.sampleRate); const fsOutput = fsNoiseBuffer.getChannelData(0); for (let i = 0; i < fsBufferSize; i++) { fsOutput[i] = Math.random() * 2 - 1; } source.buffer = fsNoiseBuffer; filter = currentAudioContext.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.setValueAtTime(3000, startTime); filter.Q.setValueAtTime(5, startTime); gain.gain.setValueAtTime(0, startTime); gain.gain.linearRampToValueAtTime(0.9, startTime + 0.005); gain.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.08); duration = 0.09; source.connect(filter).connect(gain); break; case "Hi-Hat": const bufferSize = currentAudioContext.sampleRate * 0.1; const noiseBuffer = currentAudioContext.createBuffer(1, bufferSize, currentAudioContext.sampleRate); const output = noiseBuffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; } source = currentAudioContext.createBufferSource(); source.buffer = noiseBuffer; filter = currentAudioContext.createBiquadFilter(); filter.type = 'highpass'; filter.frequency.setValueAtTime(7000, startTime); gain.gain.setValueAtTime(0.6, startTime); gain.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.05); duration = 0.06; source.connect(filter).connect(gain); break; case "Kick": source = currentAudioContext.createOscillator(); source.type = 'sine'; source.frequency.setValueAtTime(150, startTime); source.frequency.exponentialRampToValueAtTime(50, startTime + 0.1); gain.gain.setValueAtTime(1.5, startTime); gain.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.15); duration = 0.16; source.connect(gain); break; } if (source) { source.start(startTime); source.stop(startTime + duration + 0.01); if (!isOfflineContext) { activeDrumAudioNodes[drumKey] = { source, gain, filter, expectedEndTime: startTime + duration + 0.01 }; source.onended = () => { if (activeDrumAudioNodes[drumKey] && activeDrumAudioNodes[drumKey].source === source && currentAudioContext.currentTime >= activeDrumAudioNodes[drumKey].expectedEndTime - 0.005) { if (activeDrumAudioNodes[drumKey].gain) activeDrumAudioNodes[drumKey].gain.disconnect(); if (activeDrumAudioNodes[drumKey].filter) activeDrumAudioNodes[drumKey].filter.disconnect(); try { source.disconnect(); } catch (e) {/*ignore*/} delete activeDrumAudioNodes[drumKey]; }}; } }}
            function tick() { if (!audioContext) return; const currentTime = audioContext.currentTime; const stepDuration = (60 / tempoBPM) / 4; const subStepDuration = stepDuration / 2; for (let note = 0; note < NUM_NOTES; note++) { if (!notesData[note] || !notesData[note][currentStep]) continue; const cellData = notesData[note][currentStep]; if (cellData.isSplit && cellData.subNotes) { if (cellData.subNotes[0] && cellData.subNotes[0].duration > 0) { playNoteSound(note, cellData.subNotes[0].duration * stepDuration, currentTime, `seq-${note}-${currentStep}-0`, audioContext); } if (cellData.subNotes[1] && cellData.subNotes[1].duration > 0) { playNoteSound(note, cellData.subNotes[1].duration * stepDuration, currentTime + subStepDuration, `seq-${note}-${currentStep}-1`, audioContext); }} else if (!cellData.isSplit && cellData.noteInfo && cellData.noteInfo.duration > 0) { const noteDurationSeconds = cellData.noteInfo.duration * stepDuration; playNoteSound(note, noteDurationSeconds, currentTime, `seq-${note}-${currentStep}`, audioContext); }} for (let track = 0; track < NUM_DRUM_TRACKS; track++) { if (!drumNotesData[track] || !drumNotesData[track][currentStep]) continue; const cellData = drumNotesData[track][currentStep]; if (cellData.isSplit && cellData.subActive) { if (cellData.subActive[0]) { playDrumSound(track, currentTime, `seq-drum-${track}-${currentStep}-0`, audioContext); } if (cellData.subActive[1]) { playDrumSound(track, currentTime + subStepDuration, `seq-drum-${track}-${currentStep}-1`, audioContext); }} else if (!cellData.isSplit && cellData.active) { playDrumSound(track, currentTime, `seq-drum-${track}-${currentStep}`, audioContext); }} if (currentStep === currentNumSteps - 1 && !shouldLoop) { stopPlayback(); currentStep = 0; highlightCurrentStepColumn(); return; } currentStep = (currentStep + 1) % currentNumSteps; highlightCurrentStepColumn(); }
            function startPlayback() { if (isPlaying) return; if (!initAudioContext()) return; isPlaying = true; playBtn.disabled = true; stopBtn.disabled = false; highlightCurrentStepColumn(); tick(); const intervalTimeMs = ((60 / tempoBPM) / 4) * 1000; if (intervalId) clearInterval(intervalId); intervalId = setInterval(tick, intervalTimeMs); }
            function stopPlayback() { isPlaying = false; playBtn.disabled = false; stopBtn.disabled = true; if (intervalId) clearInterval(intervalId); intervalId = null; const currentTime = audioContext ? audioContext.currentTime : 0; Object.values(activeAudioNodes).forEach(entry => { if (entry && entry.masterGain && entry.source) { try { entry.masterGain.gain.cancelScheduledValues(currentTime); entry.masterGain.gain.setValueAtTime(entry.masterGain.gain.value, currentTime); entry.masterGain.gain.linearRampToValueAtTime(0.00001, currentTime + 0.01); if (entry.source.stop) { entry.source.stop(currentTime + 0.02); } setTimeout(() => { if (entry.nodes) { entry.nodes.forEach(node => { try { node.disconnect(); } catch(e) { /* ignore */ } }); }}, 30); } catch (e) { console.warn("Error stopping melody node on stopPlayback:", e); } }}); activeAudioNodes = {}; Object.values(activeDrumAudioNodes).forEach(entry => { if (entry && entry.source) { try { if (entry.gain) { entry.gain.gain.cancelScheduledValues(currentTime); entry.gain.gain.setValueAtTime(entry.gain.gain.value, currentTime); entry.gain.gain.linearRampToValueAtTime(0.00001, currentTime + 0.01); } if (entry.source.stop) { entry.source.stop(currentTime + 0.02); } setTimeout(() => { if(entry.gain) entry.gain.disconnect(); if(entry.filter) entry.filter.disconnect(); try { entry.source.disconnect(); } catch(e) {/*ignore*/} }, 30); } catch (e) { console.warn("Error stopping drum node on stopPlayback:", e); } }}); activeDrumAudioNodes = {}; highlightCurrentStepColumn(); }
            
            function clearGrid() {
                if (isPlaying) stopPlayback();
                initializeGridData(); 
                renderNotes();
                initializeDrumGridData(); 
                renderDrumNotes();
                saveStateForUndo();
            }
            function updateTempo() { tempoBPM = parseFloat(tempoInput.value); if (tempoBPM < 20) tempoBPM = 20; if (tempoBPM > 600) tempoBPM = 600; tempoInput.value = tempoBPM; if (isPlaying) { stopPlayback(); startPlayback(); } }
            function updateInstrument() { /* No change needed */ }
            
            function addStep() {
                if (isPlaying) stopPlayback();
                currentNumSteps++; 
                
                notesData.forEach(row => {
                    while(row.length < currentNumSteps -1) row.push(createDefaultMelodyCellData());
                    row.push(createDefaultMelodyCellData()); 
                });
                drumNotesData.forEach(row => {
                    while(row.length < currentNumSteps -1) row.push(createDefaultDrumCellData());
                    row.push(createDefaultDrumCellData());
                });

                initializeGridStructure(); 
                renderNotes(); 
                initializeDrumGridStructure();
                renderDrumNotes();

                stepCountLabel.textContent = `${currentNumSteps}`;
                updateRemoveStepButtonState();
                saveStateForUndo();
            }

            function removeStep() {
                if (currentNumSteps <= 1) return;
                if (isPlaying) stopPlayback();
                
                currentNumSteps--;
                if (currentStep >= currentNumSteps) currentStep = Math.max(0, currentNumSteps - 1);

                notesData.forEach(row => { if(row.length > currentNumSteps) row.length = currentNumSteps; });
                drumNotesData.forEach(row => { if(row.length > currentNumSteps) row.length = currentNumSteps; });

                initializeGridStructure();
                renderNotes();
                initializeDrumGridStructure();
                renderDrumNotes();
                
                stepCountLabel.textContent = `${currentNumSteps}`;
                updateRemoveStepButtonState();
                saveStateForUndo();
            }

            function updateRemoveStepButtonState() { removeStepBtn.disabled = currentNumSteps <= 1; }
            
            function duplicateAndAppendTrack() {
                if (isPlaying) stopPlayback();
                const originalNumSteps = currentNumSteps;
                currentNumSteps *= 2;

                const newMelodyData = [];
                for (let n = 0; n < NUM_NOTES; n++) {
                    newMelodyData[n] = [];
                    for (let s = 0; s < originalNumSteps; s++) {
                        const sourceCell = (notesData[n] && notesData[n][s]) ? notesData[n][s] : createDefaultMelodyCellData();
                        newMelodyData[n][s] = JSON.parse(JSON.stringify(sourceCell));
                        newMelodyData[n][s + originalNumSteps] = JSON.parse(JSON.stringify(sourceCell));
                    }
                }
                notesData = newMelodyData;

                const newDrumData = [];
                for (let t = 0; t < NUM_DRUM_TRACKS; t++) {
                    newDrumData[t] = [];
                    for (let s = 0; s < originalNumSteps; s++) {
                        const sourceCell = (drumNotesData[t] && drumNotesData[t][s]) ? drumNotesData[t][s] : createDefaultDrumCellData();
                        newDrumData[t][s] = JSON.parse(JSON.stringify(sourceCell));
                        newDrumData[t][s + originalNumSteps] = JSON.parse(JSON.stringify(sourceCell));
                    }
                }
                drumNotesData = newDrumData;
                
                initializeGridStructure();
                renderNotes();
                initializeDrumGridStructure();
                renderDrumNotes();

                stepCountLabel.textContent = `${currentNumSteps}`;
                updateRemoveStepButtonState();
                saveStateForUndo();
            }

            function saveStateForUndo(isInitial = false) {
                const state = {
                    notesData: JSON.parse(JSON.stringify(notesData)),
                    drumNotesData: JSON.parse(JSON.stringify(drumNotesData)),
                    currentNumSteps: currentNumSteps
                };
                undoStack.push(state);
                if (undoStack.length > MAX_HISTORY_SIZE) {
                    undoStack.shift();
                }
                if (!isInitial) { 
                    redoStack = [];
                }
                updateUndoRedoButtons();
            }

            function restoreState(state) {
                if (!state) return;
                if (isPlaying) stopPlayback();

                currentNumSteps = state.currentNumSteps;
                notesData = JSON.parse(JSON.stringify(state.notesData));
                drumNotesData = JSON.parse(JSON.stringify(state.drumNotesData));

                initializeGridStructure();
                renderNotes();
                initializeDrumGridStructure();
                renderDrumNotes();

                stepCountLabel.textContent = `${currentNumSteps}`;
                updateRemoveStepButtonState();
                updateUndoRedoButtons();
            }

            function undo() {
                if (undoStack.length === 0) return;
                
                const currentState = {
                    notesData: JSON.parse(JSON.stringify(notesData)),
                    drumNotesData: JSON.parse(JSON.stringify(drumNotesData)),
                    currentNumSteps: currentNumSteps
                };
                redoStack.push(currentState);
                if (redoStack.length > MAX_HISTORY_SIZE) redoStack.shift();

                const prevState = undoStack.pop();
                restoreState(prevState);
                updateUndoRedoButtons();
            }

            function redo() {
                if (redoStack.length === 0) return;
                
                const currentState = {
                    notesData: JSON.parse(JSON.stringify(notesData)),
                    drumNotesData: JSON.parse(JSON.stringify(drumNotesData)),
                    currentNumSteps: currentNumSteps
                };
                undoStack.push(currentState);
                if (undoStack.length > MAX_HISTORY_SIZE) undoStack.shift();

                const nextState = redoStack.pop();
                restoreState(nextState);
                updateUndoRedoButtons();
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }

            function writeString(view, offset, string) { for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); } }
            function audioBufferToWav(buffer) { const numChannels = buffer.numberOfChannels; const sampleRate = buffer.sampleRate; const format = 1; const bitDepth = 16; const blockAlign = numChannels * (bitDepth / 8); const byteRate = sampleRate * blockAlign; const numSamples = buffer.length; const dataSize = numSamples * blockAlign; const fileSize = 44 + dataSize; const wavBuffer = new ArrayBuffer(fileSize); const view = new DataView(wavBuffer); let offset = 0; writeString(view, offset, 'RIFF'); offset += 4; view.setUint32(offset, fileSize - 8, true); offset += 4; writeString(view, offset, 'WAVE'); offset += 4; writeString(view, offset, 'fmt '); offset += 4; view.setUint32(offset, 16, true); offset += 4; view.setUint16(offset, format, true); offset += 2; view.setUint16(offset, numChannels, true); offset += 2; view.setUint32(offset, sampleRate, true); offset += 4; view.setUint32(offset, byteRate, true); offset += 4; view.setUint16(offset, blockAlign, true); offset += 2; view.setUint16(offset, bitDepth, true); offset += 2; writeString(view, offset, 'data'); offset += 4; view.setUint32(offset, dataSize, true); offset += 4; const pcmData = new Int16Array(numSamples * numChannels); let pcmIdx = 0; for (let i = 0; i < numSamples; i++) { for (let ch = 0; ch < numChannels; ch++) { const channelData = buffer.getChannelData(ch); let s = Math.max(-1, Math.min(1, channelData[i])); pcmData[pcmIdx++] = s < 0 ? s * 0x8000 : s * 0x7FFF; }} for(let i=0; i < pcmData.length; i++){ view.setInt16(offset + (i*2), pcmData[i], true); } return new Blob([view], { type: 'audio/wav' }); }
            async function exportSequenceAsWav() { if (isPlaying) { alert("Please stop playback before exporting."); return; } const hasMelody = notesData.some(row => row.some(cell => (cell.isSplit && cell.subNotes && (cell.subNotes[0] || cell.subNotes[1])) || (!cell.isSplit && cell.noteInfo) )); const hasDrums = drumNotesData.some(row => row.some(cell => (cell.isSplit && cell.subActive && (cell.subActive[0] || cell.subActive[1])) || (!cell.isSplit && cell.active) )); if (!hasMelody && !hasDrums) { alert("No notes to export."); return; } exportWavBtn.disabled = true; exportWavBtn.textContent = "…"; try { const stepDuration = (60 / tempoBPM) / 4; const subStepDuration = stepDuration / 2; const totalDurationSeconds = currentNumSteps * stepDuration; const sampleRate = 44100; const numChannelsForExport = 2;  const offlineCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(numChannelsForExport, Math.ceil(sampleRate * (totalDurationSeconds + 1.0)), sampleRate); for (let step = 0; step < currentNumSteps; step++) { const scheduleTime = step * stepDuration; for (let note = 0; note < NUM_NOTES; note++) { if (!notesData[note] || !notesData[note][step]) continue; const cellData = notesData[note][step]; if (cellData.isSplit && cellData.subNotes) { if (cellData.subNotes[0] && cellData.subNotes[0].duration > 0) playNoteSound(note, cellData.subNotes[0].duration * stepDuration, scheduleTime, `export-m-${note}-${step}-0`, offlineCtx); if (cellData.subNotes[1] && cellData.subNotes[1].duration > 0) playNoteSound(note, cellData.subNotes[1].duration * stepDuration, scheduleTime + subStepDuration, `export-m-${note}-${step}-1`, offlineCtx); } else if (!cellData.isSplit && cellData.noteInfo && cellData.noteInfo.duration > 0) { playNoteSound(note, cellData.noteInfo.duration * stepDuration, scheduleTime, `export-m-${note}-${step}`, offlineCtx); }} for (let track = 0; track < NUM_DRUM_TRACKS; track++) { if (!drumNotesData[track] || !drumNotesData[track][step]) continue; const cellData = drumNotesData[track][step]; if (cellData.isSplit && cellData.subActive) { if (cellData.subActive[0]) playDrumSound(track, scheduleTime, `export-d-${track}-${step}-0`, offlineCtx); if (cellData.subActive[1]) playDrumSound(track, scheduleTime + subStepDuration, `export-d-${track}-${step}-1`, offlineCtx); } else if (!cellData.isSplit && cellData.active) { playDrumSound(track, scheduleTime, `export-d-${track}-${step}`, offlineCtx); }}} const renderedBuffer = await offlineCtx.startRendering(); const wavBlob = audioBufferToWav(renderedBuffer); const downloadUrl = URL.createObjectURL(wavBlob); const anchor = document.createElement('a'); anchor.href = downloadUrl; const currentTempoForFilename = tempoBPM; let collectedPitchNamesForFilename = []; const maxNotesInFilename = 10; for (let s_fn = 0; s_fn < currentNumSteps && collectedPitchNamesForFilename.length < maxNotesInFilename; s_fn++) { let notesInCurrentStepThisIteration = []; for (let n_fn = 0; n_fn < NUM_NOTES; n_fn++) { if (!notesData[n_fn] || !notesData[n_fn][s_fn]) continue; const cellData_fn = notesData[n_fn][s_fn]; if (!cellData_fn.isSplit && cellData_fn.noteInfo && cellData_fn.noteInfo.duration > 0) { const pitchName = NOTE_NAMES[n_fn].replace(/[0-9]/g, ''); notesInCurrentStepThisIteration.push(pitchName); }} for (const pitchName of notesInCurrentStepThisIteration) { if (collectedPitchNamesForFilename.length < maxNotesInFilename) { collectedPitchNamesForFilename.push(pitchName); } else { break; } }} let filenameNotesPart = "NoMelody"; if (collectedPitchNamesForFilename.length > 0) { filenameNotesPart = collectedPitchNamesForFilename.join('-'); } else if (hasDrums && !hasMelody) { filenameNotesPart = "DrumTrack"; } anchor.download = `${currentTempoForFilename}-${filenameNotesPart}.wav`; document.body.appendChild(anchor); anchor.click(); document.body.removeChild(anchor); URL.revokeObjectURL(downloadUrl); console.log("Export finished."); } catch (error) { console.error("Error exporting WAV:", error); alert("Error exporting WAV: " + error.message); } finally { exportWavBtn.disabled = false; exportWavBtn.textContent = "↓"; }}

            playBtn.addEventListener('click', () => { if (!isPlaying) currentStep = 0; startPlayback(); });
            stopBtn.addEventListener('click', stopPlayback);
            clearBtn.addEventListener('click', clearGrid);
            tempoInput.addEventListener('change', updateTempo);
            instrumentSelect.addEventListener('change', updateInstrument); 
            addStepBtn.addEventListener('click', addStep);
            removeStepBtn.addEventListener('click', removeStep);
            loopBtn.addEventListener('click', () => {
                shouldLoop = !shouldLoop;
                loopBtn.classList.toggle('active-mode', shouldLoop);
            });
            duplicateAppendBtn.addEventListener('click', duplicateAndAppendTrack);
            exportWavBtn.addEventListener('click', exportSequenceAsWav); 
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            
            splitCellBtn.addEventListener('click', () => {
                isSplitCellMode = !isSplitCellMode;
                splitCellBtn.classList.toggle('active-mode', isSplitCellMode);
                const cursorStyle = isSplitCellMode ? 'crosshair' : 'default';
                gridContainer.style.cursor = cursorStyle;
                drumGridContainer.style.cursor = cursorStyle;
                if (!isSplitCellMode && draggingNoteInfo) {
                    // No specific action needed
                }
            });

            // MODIFIED: Added event listener for sustainNoteBtn
            sustainNoteBtn.addEventListener('click', () => {
                isSustainNoteMode = !isSustainNoteMode;
                sustainNoteBtn.classList.toggle('active-mode', isSustainNoteMode);
                // No cursor change needed for sustain mode, as interaction is on existing notes
            });

            document.addEventListener('keydown', (event) => {
                if ((event.ctrlKey || event.metaKey) && event.key === 'z') {
                    event.preventDefault();
                    if (!undoBtn.disabled) undo();
                } else if ((event.ctrlKey || event.metaKey) && event.key === 'y') {
                    event.preventDefault();
                    if (!redoBtn.disabled) redo();
                }
            });
            
            init(); 

            const gridTouchState = {
                isPanning: false,
                startX: 0,
                startY: 0,
                initialScrollLeft: 0,
                initialScrollTop: 0
            };

            gridContainer.addEventListener('touchstart', (e) => {
                if (e.touches.length >= 2) { 
                    if (noteInteractionDebounceTimer) {
                        clearTimeout(noteInteractionDebounceTimer);
                        noteInteractionDebounceTimer = null;
                    }
                    if (drumInteractionDebounceTimer) {
                        clearTimeout(drumInteractionDebounceTimer);
                        drumInteractionDebounceTimer = null;
                    }
                    
                    gridTouchState.isPanning = true; 
                    e.preventDefault(); 
                    
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    gridTouchState.startX = (touch1.clientX + touch2.clientX) / 2;
                    gridTouchState.startY = (touch1.clientY + touch2.clientY) / 2;
                    gridTouchState.initialScrollLeft = gridContainer.scrollLeft;
                    gridTouchState.initialScrollTop = gridContainer.scrollTop;
                    
                    gridContainer.style.userSelect = 'none';
                    gridContainer.style.webkitUserSelect = 'none'; 
                    gridContainer.style.msUserSelect = 'none'; 
                }
            }, { passive: false });

            gridContainer.addEventListener('touchmove', (e) => {
                if (gridTouchState.isPanning && e.touches.length >= 2) { 
                    e.preventDefault(); 
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentX = (touch1.clientX + touch2.clientX) / 2;
                    const currentY = (touch1.clientY + touch2.clientY) / 2;

                    const deltaX = currentX - gridTouchState.startX;
                    const deltaY = currentY - gridTouchState.startY;

                    gridContainer.scrollLeft = gridTouchState.initialScrollLeft - deltaX;
                    gridContainer.scrollTop = gridTouchState.initialScrollTop - deltaY;
                }
            }, { passive: false });

            const resetGridTouchPanningState = () => {
                if (gridTouchState.isPanning) {
                    gridTouchState.isPanning = false;
                    gridContainer.style.userSelect = '';
                    gridContainer.style.webkitUserSelect = '';
                    gridContainer.style.msUserSelect = '';
                }
            };

            gridContainer.addEventListener('touchend', resetGridTouchPanningState);
            gridContainer.addEventListener('touchcancel', resetGridTouchPanningState);


            if (gridContainer && drumGridContainer) { 
                let scrollTimer = null;
                gridContainer.addEventListener('scroll', () => { 
                    if (scrollTimer) clearTimeout(scrollTimer); 
                    scrollTimer = setTimeout(() => { 
                        drumGridContainer.scrollLeft = gridContainer.scrollLeft; 
                        scrollTimer = null; 
                    }, 1); 
                });
            }

            function setAppHeight() {
                const appContainer = document.querySelector('.container');
                if (appContainer) {
                    appContainer.style.height = `${window.innerHeight}px`;
                }
            }
            window.addEventListener('resize', setAppHeight);
            window.addEventListener('orientationchange', setAppHeight);
        });
    </script>
</body>
</html>